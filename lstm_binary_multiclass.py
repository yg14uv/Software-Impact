# -*- coding: utf-8 -*-
"""RNN_Binary_Multiclass.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1M5uUDuRau28KgLSycB13Gajkq6poDz_R

##**RNN based Binary Classification of Anomilies in IOT data**
"""

# Importing desired libraries
import numpy as np
import tensorflow as tf
import pandas as pd
from tensorflow import keras
from matplotlib import pyplot as plt
import matplotlib.pyplot as plt


#loading dataset
data = pd.read_csv('IoTID20.csv')

# displaying some initial data
data.head(5)

#calculating sum
data.isnull().sum().sum()

# dropping unnecessary columns
data = data.drop(columns = ['Flow_ID', 'Src_IP', 'Src_Port', 'Dst_IP', 'Dst_Port', 'Protocol','Timestamp', 'Cat', 'Sub_Cat','Fwd_PSH_Flags','Fwd_URG_Flags','Fwd_Byts/b_Avg','Fwd_Pkts/b_Avg','Fwd_Blk_Rate_Avg','Bwd_Byts/b_Avg','Bwd_Pkts/b_Avg','Bwd_Blk_Rate_Avg','Init_Fwd_Win_Byts','Fwd_Seg_Size_Min'])

# replacing with numeric values
data.Label.replace(['Anomaly', 'Normal'], [1, 0], inplace = True)

# normalizing data
normalized_df = (data-data.min())/(data.max()-data.min())

normalized_df = normalized_df.dropna()

features = normalized_df.drop(columns=['Label']).to_numpy()
labels = normalized_df[['Label']].to_numpy()

# checking shape of features
features.shape, labels.shape

# splitting training and test sets
x_train = features[:575783]
y_train = labels[:575783]

x_test = features[575783:]
y_test = labels[575783:]

# checking shape of features
x_train.shape , x_test.shape , y_train.shape , y_test.shape

# reshaping data
x_train1 = x_train.reshape((575783, 1 , 66))
x_test1 = x_test.reshape((49632,1,66))
x_test1.shape , x_train1.shape

# creating neural network model
modelbinary = keras.Sequential([
              keras.layers.LSTM(128, input_shape=(1,66), return_sequences=True),
              keras.layers.LSTM(30,return_sequences=True),
              keras.layers.Dense(1,activation='sigmoid')         
])

# compiling model
modelbinary.compile(optimizer='adam',
              loss='binary_crossentropy',
              metrics=['accuracy'])

# training model
history = modelbinary.fit(x_train1, y_train, epochs = 5)

# evaluating model
loss,accuracy = modelbinary.evaluate(x_test1,y_test)
print("Loss: ", loss)
print('Accuracy: ',accuracy*100, '%')

# plotting results
plt.style.use('seaborn')


plt.figure()
plt.plot(history.history['accuracy'])
#plt.plot(history.history['val_accuracy'])
plt.title('model accuracy')
plt.ylabel('accuracy')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
#plt.show()
#plt.savefig(fname='model_accuracy_'+db+'.png')

# summarize history for loss
plt.figure()
plt.plot(history.history['loss'])
plt.plot(history.history['loss'])
plt.title('model loss')
plt.ylabel('loss')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
#plt.show()
#plt.savefig(fname='model_loss_'+db+'.png')

"""##**RNN based MultiClass Classification of Anomilies in IOT data**"""

# preprocessing data
data2 = pd.read_csv('IoTID20.csv')
data2 = data2.drop(columns = ['Flow_ID', 'Src_IP', 'Src_Port', 'Dst_IP', 'Dst_Port', 'Protocol','Timestamp','Fwd_PSH_Flags','Fwd_URG_Flags','Fwd_Byts/b_Avg','Fwd_Pkts/b_Avg','Fwd_Blk_Rate_Avg','Bwd_Byts/b_Avg','Bwd_Pkts/b_Avg','Bwd_Blk_Rate_Avg','Init_Fwd_Win_Byts','Fwd_Seg_Size_Min'])
data2.Label.replace(['Anomaly', 'Normal'], [1, 0], inplace = True)
data2.Cat.replace(['Mirai', 'DoS','Scan','Normal','MITM ARP Spoofing'], [1,2,3,4,5], inplace = True)
data2.Sub_Cat.replace(['Mirai-Ackflooding', 'DoS-Synflooding','Scan Port OS','Mirai-Hostbruteforceg','Mirai-UDP Flooding', 'Mirai-HTTP Flooding','Normal', 'Scan Hostport', 'MITM ARP Spoofing'], [1,2,3,4,5,6,7,8,9], inplace = True)

# data normalization
normalized_df2 = (data2-data2.min())/(data2.max()-data2.min())

normalized_df2 = normalized_df2.dropna()

features2 = normalized_df2.drop(columns=['Label','Cat','Sub_Cat']).to_numpy()
labels2 = normalized_df2[['Label','Cat','Sub_Cat']].to_numpy()

# splitting training and testing data
x_train2 = features2[:575783]
y_train2 = labels2[:575783]

x_test2 = features2[575783:]
y_test2 = labels2[575783:]

x_train2.shape , x_test2.shape , y_train2.shape , y_test2.shape

x_train21 = x_train2.reshape((575783, 1 , 66))
x_test21 = x_test2.reshape((49632,1,66))
y_train21 =  y_train2.reshape(575783,1,3)
y_test21 =  y_test2.reshape(49632,1,3)
x_test21.shape , x_train21.shape

# creating RNN model
model2 = keras.Sequential([
              keras.layers.SimpleRNN(128, input_shape=(1,66), return_sequences=True),
              keras.layers.SimpleRNN(30,return_sequences=True),
              keras.layers.Dense(3,activation='softmax')       
])

# displaying model structure
model2.summary()

#compiling model
model2.compile(optimizer='adam',
              loss='categorical_crossentropy',
              metrics=['accuracy'])

# training model
history = model2.fit(x_train21,y_train21, epochs = 5)

# evaluating model
loss,accuracy = model2.evaluate(x_test21,y_test21)
print("Loss: ", loss)
print('Accuracy: ',accuracy*100, '%')

# plotting results
plt.style.use('seaborn')


plt.figure()
plt.plot(history.history['accuracy'])
#plt.plot(history.history['val_accuracy'])
plt.title('model accuracy')
plt.ylabel('accuracy')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
#plt.show()
#plt.savefig(fname='model_accuracy_'+db+'.png')

# summarize history for loss
plt.figure()
plt.plot(history.history['loss'])
plt.plot(history.history['loss'])
plt.title('model loss')
plt.ylabel('loss')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
#plt.show()
#plt.savefig(fname='model_loss_'+db+'.png')

"""## **Result:**
Using Simple RNN model for binary classification achieved an accuracy of: <br>
training :98.48%<br>
testing: 98.22%<br>

For multiclass classification:<br>
training: 93.60%<br>
testing: 93.53%<br>
"""